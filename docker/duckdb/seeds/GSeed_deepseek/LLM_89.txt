-- Create tables with different data types and constraints
CREATE TABLE t1 (
    id INTEGER PRIMARY KEY,
    name VARCHAR(50),
    value FLOAT,
    enabled BOOLEAN DEFAULT FALSE,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE t2 (
    id INTEGER REFERENCES t1(id),
    category VARCHAR(30) NOT NULL,
    quantity INTEGER CHECK (quantity >= 0)
);

-- Insert test data with edge cases and NULL values
INSERT INTO t1 VALUES 
    (1, 'Alice', 100.5, TRUE, '2024-01-01'),
    (2, 'Bob', -50.3, FALSE, '2024-01-02'),
    (3, NULL, 0, NULL, CURRENT_TIMESTAMP),
    (4, 'Charlie', 123.456, TRUE, '2024-01-03');

INSERT INTO t2 VALUES 
    (1, 'Electronics', 10),
    (2, 'Clothing', 0),
    (3, 'Books', NULL),
    (4, 'Toys', 99);

-- Test update and delete operations
UPDATE t1 SET enabled = NOT enabled WHERE id IN (1, 3);
DELETE FROM t2 WHERE quantity < 5;

-- Test aggregate functions and grouping
SELECT 
    COUNT(*) AS total_records,
    SUM(value) AS sum_value,
    AVG(value) AS avg_value,
    MIN(value) AS min_value,
    MAX(value) AS max_value
FROM t1;

-- Test window functions and CTEs
WITH ranked_data AS (
    SELECT 
        id, name, value,
        RANK() OVER (ORDER BY value DESC) AS rank,
        NTILE(2) OVER (ORDER BY last_updated) AS ntile_group
    FROM t1
)
SELECT * FROM ranked_data WHERE rank <= 5;

-- Test joins and subqueries
SELECT 
    t1.name, t2.category, t2.quantity
FROM t1
JOIN t2 ON t1.id = t2.id
WHERE t2.quantity > (SELECT AVG(quantity) FROM t2);

-- DuckDB-specific functionality test
SELECT 
    id,
    name,
    value,
    enabled,
    last_updated,
    TO_UNIXTIME(last_updated) AS unix_timestamp,
    STRFTIME('%Y-%m-%d', last_updated) AS formatted_date
FROM t1
WHERE enabled = TRUE;