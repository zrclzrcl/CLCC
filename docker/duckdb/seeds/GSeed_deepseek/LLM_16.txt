-- Create a table with various data types and constraints
CREATE TABLE t1 (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    value REAL DEFAULT 0.0,
    data BLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(name)
);

-- Create another table for testing joins and foreign keys
CREATE TABLE t2 (
    id INTEGER PRIMARY KEY,
    t1_id INTEGER REFERENCES t1(id),
    category TEXT CHECK (category IN ('A', 'B', 'C'))
);

-- Insert sample data into t1 and t2
INSERT INTO t1 VALUES (1, 'test1', 100.5, X'ABCD', CURRENT_TIMESTAMP);
INSERT INTO t1 VALUES (2, 'test2', NULL, NULL, CURRENT_TIMESTAMP);
INSERT INTO t2 VALUES (1, 1, 'A');
INSERT INTO t2 VALUES (2, NULL, 'B');

-- Alter table to add a new column
ALTER TABLE t1 ADD COLUMN status TEXT DEFAULT 'active';

-- Test a complex query with window functions and CTEs
WITH cte AS (
    SELECT id, name, RANK() OVER (ORDER BY value DESC) as rank
    FROM t1
)
SELECT * FROM cte WHERE rank <= 2;

-- Create an index on the status column for testing query optimization
CREATE INDEX idx_status ON t1(status);

-- Test a recursive CTE to exercise stack handling
WITH RECURSIVE numbers(n) AS (
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM numbers WHERE n < 10
)
SELECT * FROM numbers;

-- Create a view with complex logic
CREATE VIEW v1 AS
SELECT t1.id, t1.name, t2.category, COUNT(*) as count
FROM t1 LEFT JOIN t2 ON t1.id = t2.t1_id
GROUP BY t1.id, t1.name, t2.category
HAVING COUNT(*) > 0;

-- Insert into the view to test updatable views
INSERT INTO v1 VALUES (3, 'test3', 'C', 1);

-- Use a PRAGMA specific to DuckDB for testing configuration changes
PRAGMA enable_experimental_functions = true;

-- Drop and recreate a table to test schema changes
DROP TABLE IF EXISTS t3;
CREATE TABLE t3 (
    id INTEGER PRIMARY KEY,
    data JSON
);
INSERT INTO t3 VALUES (1, '{"key": "value"}');

COMMIT;